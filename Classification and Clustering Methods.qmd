## Introduction

In today's lab, you'll practice building `workflowsets` with `recipes`, `parsnip` models, `rsample` cross validations, model tuning and model comparison in the context of classification and clustering.

### Learning goals

By the end of the lab you will...

-   Be able to build workflows to fit different classification models.
-   Be able to build workflows to evaluate different clustering models.

## Getting started

-   To complete the lab, log on to **your** github account and then go to the class [GitHub organization](https://github.com/bsmm-8740-fall-2025) and find the **2025-lab-5-\[your github username\]** repository .

    Create an R project using your **2025-lab-5-\[your github username\]** repository (remember to create a PAT, etc.) and add your answers by editing the `2025-lab-5.qmd` file in your repository.

-   When you are done, be sure to: **save** your document, **stage**, **commit** and [**push**]{.underline} your work.

::: callout-important
To access Github from the lab, you will need to make sure you are logged in as follows:

-   username: **.\\daladmin**
-   password: **Business507!**

Remember to (create a PAT and set your git credentials)

-   create your PAT using `usethis::create_github_token()` ,
-   store your PAT with `gitcreds::gitcreds_set()` ,
-   set your username and email with
    -   `usethis::use_git_config( user.name = ___, user.email = ___)`
:::

## Packages

```{r}
# check if 'librarian' is installed and if not, install it
if (! "librarian" %in% rownames(installed.packages()) ){
  install.packages("librarian")
}
  
# load packages if not already loaded
librarian::shelf(tidyverse, magrittr, gt, gtExtras, tidymodels, ggplot2)

# set the default theme for plotting
theme_set(theme_bw(base_size = 18) + theme(legend.position = "top"))
```

::: callout-warning
## Package installs

If you install packages outside of the ones here, [**remove**]{.underline} your `install.packages(.)` code [**before submitting your solutions**]{.underline}.

Leaving instructions that will install packages may cause your code to fail, but more importantly, it can corrupt the TA/instructor's system.
:::

## The Data

Today we will be using customer churn data.

In the customer management lifecycle, customer churn refers to a decision made by the customer about ending the business relationship. It is also referred as loss of clients or customers. This dataset contains 20 features related to churn in a telecom context and we will look at how to predict churn and estimate the effect of predictors on the customer churn odds ratio.

```{r}
data74 <- 
  readr::read_csv("C:/Users/abedi/Downloads/Telco-Customer-Churn.csv", show_col_types = FALSE) |>
  dplyr::mutate(churn = as.factor(churn))

data74 %>%  dplyr::slice_head(n=5) |> 
  dplyr::glimpse()
```

## Exercise 1: EDA

Write and execute the code to perform summary EDA on the data using the package `skimr`. Plot histograms for monthly charges and tenure. Tenure measures the strength of the customer relationship by measuring the length of time that a person has been a customer.

## YOUR ANSWER Q1:

```{r}
data74 %>% skimr::skim()

data74 %>%  ggplot(aes(x=monthly_charges)) +geom_histogram()

data74 %>%  ggplot(aes(x=tenure)) +geom_histogram()

```

## Exercise 2: train / test splits & recipe

Write and execute code to create training and test datasets. Have the training dataset represent 70% of the total data.

Next create a recipe where churn is related to all the other variables, and

-   normalize the numeric variables
-   create dummy variables for the ordinal predictors

Make sure the steps are in a sequence that preserves the (0,1) dummy variables.

Prep the data on the training data and show the result.

## YOUR ANSWER Q2:

```{r}
set.seed(6666)

data74_splits <- rsample::initial_split(data74, prop = 0.7)
data74_train <- rsample::training(data74_splits)
data74_test <- rsample::testing(data74_splits)

data74_recipe <- data74_train %>% 
  recipes::recipe(churn ~ .) %>% 
  recipes::step_normalize(recipes::all_numeric_predictors()) %>% 
  recipes::step_dummy(recipes::all_nominal_predictors())

data74_recipe %>%  recipes::prep(data74_train) %>% summary()



```

## Exercise 3: logistic modeling

1.  Create a linear model using logistic regression to predict churn. for the *set engine* stage use "glm," and set the mode to "classification."
2.  Create a workflow using the recipe of the last exercise and the model if the last step.
3.  With the workflow, fit the training data
4.  Combine the training data and the predictions from step 3 using `broom::augment` , and assign the result to a variable
5.  Create a combined metric function using `yardstick::metric_set` as show in the code below:
6.  Use the variable from step 4 as the first argument to the function from step 5. The other arguments are `truth = churn` (from the data) and `estimate=.pred_class` (from step 4). Make a note of the numerical metrics.
7.  Use the variable from step 4 as the first argument to the functions listed below, with arguments `truth = churn` and ``` estimate =``.pred_No ```.
    -   `yardstick::roc_auc`
    -   `yardstick::roc_curve` followed by `ggplot2::autoplot()`.

## rank-deficiency

You can ignore this message. It means that there are a lot of predictors.

## YOUR ANSWER Q3:

```{r}
set.seed(6666)

log_model <- parsnip::logistic_reg() %>% 
  parsnip::set_engine("glm") %>% 
  parsnip::set_mode("classification")

workflow74 <- workflows::workflow() %>% 
  workflows::add_recipe(data74_recipe) %>% 
  workflows::add_model(log_model)
  
model_fit74 <- workflow74 %>% 
  parsnip::fit(data74_train)

train_augment_result <- broom::augment(model_fit74,data74_train)

train_augment_result
```

```{r}
# create the metrics function
library(yardstick)

metric74 <- yardstick::metric_set(
  accuracy,
  precision,
  recall,
  spec,
  sens,
  npv,
  ppv
)

metric74

train_augment_result %>%  metric74(truth = churn, estimate=.pred_class)
```

```{r}
# compute roc_auc and plot the roc_curve

library(ggplot2)

train_augment_result %>%
  yardstick::roc_auc(truth = churn, .pred_No)

train_augment_result %>%
  yardstick::roc_curve(truth = churn, .pred_No) %>%  autoplot()
```

## Exercise 4: effects

Use broom::tidy() on the fit object from exercise 4 to get the predictor coefficients. Sort them in decreasing order by absolute value.

What is the effect of one additional year of [**tenure**]{.underline} on the churn odds ratio?

## YOUR ANSWER Q4:

```{r}

set.seed(6666)

fit74_table <- model_fit74 %>%  broom::tidy() %>% 
  dplyr::arrange(desc(abs(estimate)))

fit74_table %>% dplyr::filter(term == "tenure") %>% 
  dplyr::pull(estimate) %>% 
  exp()

```

The effect of one additional year of tenure on the churn odds ratio is approximately 84.6% decrease in churnin the odds of churn compared to the previous year.

## Exercise 5 knn modeling

Now we will create a K-nearest neighbours model to estimate churn. To do this, write the code for the following steps:

1.  Create a K-nearest neighbours model to predict churn using `parsnip::nearest_neighbor` with argument `neighbors = 3` which will use the three most similar data points from the training set to predict churn. For the *set engine* stage use "kknn," and set the mode to "classification."
2.  Take the workflow from exercise 3 and create a new workflow by updating the original workflow. Use `workflows::update_model` to swap out the original logistic model for the nearest neighbour model.
3.  Use the new workflow to fit the **training data**. Take the fit and use `broom::augment` to augment the fit with the **training data**.
4.  Use the augmented data from step 3 to plot the roc curve, using `yardstick::roc_curve(.pred_No, truth = churn)` as in exercise 3. How do you interpret his curve?
5.  Take the fit from step 3 and use `broom::augment` to augment the fit with the **test data**.
6.  Repeat step 4 using the augmented data from step 5.

## YOUR ANSWER Q5:

```{r}
#1 Create Model
knn_model <- parsnip::nearest_neighbor(neighbors = 3) %>% 
  parsnip::set_engine("kknn") %>% 
  parsnip::set_mode("classification")


workflow74_knn <- workflow74 %>% 
  workflows::update_model(knn_model)


fit_74 <- workflow74_knn %>% 
  parsnip::fit(data74_train)

augment_74 <- broom::augment(fit_74,data74_train )
```

```{r}
#Extra test accuracy
library(yardstick
        )
augment_74 %>%  metric74(truth = churn, estimate = .pred_class)
```

```{r}
#4 
augment_74 %>% yardstick::roc_curve(.pred_No, truth = churn) %>% autoplot()

augment_74 %>% yardstick::roc_auc(.pred_No, truth = churn)
```

```         
```

## Exercise 6 cross validation

Following the last exercise, we should have some concerns about over-fitting by the nearest-neighbour model.

To address this we will use cross validation to tune the model and evaluate the fits.

1.  Create a cross-validation dataset based on **5 folds** using `rsample::vfold_cv`.
2.  Using the **knn** workflow from exercise 5, apply `tune::fit_resamples` with arguments `resamples` and `control` where the resamples are the dataset created in step 1 and control is `tune::control_resamples(save_pred = TRUE)`, which will ensure that the predictions are saved.
3.  Use `tune::collect_metrics()` on the results from step 2
4.  Use tune::collect_predictions() on the results from step 2 to plot the roc_auc curve as in exercise 5. Has it changed much from exercise 5?

## YOUR ANSWER Q6:

```{r}


cv_knn5 <- data74 %>%  rsample::vfold_cv(v=5)

fit_knn5 <- workflow74_knn %>% 
  tune::fit_resamples(cv_knn5,
                      control = tune::control_resamples(save_pred = TRUE))


fit_knn5 %>%tune::collect_predictions()
```

```{r}
#4. plot curve


fit_knn5 %>%  tune::collect_predictions() %>% 
  yardstick::roc_curve(.pred_No, truth = churn) %>% autoplot()
```

::: render-commit-push
This is a good place to render, commit, and push changes to your remote lab repo on GitHub. Click the checkbox next to each file in the Git pane to stage the updates you've made, write an informative commit message, and push. After you push the changes, the Git pane in RStudio should be empty.
:::

## Exercise 7: tuning for k

In this exercise we'll tune the number of nearest neighbours in our model to see if we can improve performance.

1.  Redo exercise 5 steps 1 and 2, setting `neighbors = tune::tune()` for the model, and then updating the workflow with `workflows::update_model`.
2.  Use `dials::grid_regular(dials::neighbors(), levels = 10)` to create a grid for tuning **k**.
3.  Use `tune::tune_grid` with `tune::control_grid(save_pred = TRUE)` and `yardstick::metric_set(yardstick::accuracy, yardstick::roc_auc)` to generate tuning results

## YOUR ANSWER Q7:

```{r}
#1. Redo Ex.5

knn_model_tuned <- parsnip::nearest_neighbor(neighbors = tune::tune()) %>% 
   parsnip::set_engine("kknn") %>% 
  parsnip::set_mode("classification")

workflow74_knn_update <- workflow74_knn %>% 
  workflows::update_model(knn_model_tuned)

grid_74 <- dials::grid_regular(dials::neighbors(), levels = 10)

fit_tuned <- tune::tune_grid(
  workflow74_knn_update,
  resamples = cv_knn5,
  grid = grid_74,
  tune::control_grid(save_pred = TRUE),
  yardstick::metric_set(yardstick::accuracy, yardstick::roc_auc))

fit_tuned
```

## Exercise 8

Use `tune::collect_metrics()` to collect the metrics from the tuning results in exercise 7 and then plot the metrics as a function of **k** using the code below.

## YOUR ANSWER Q8:

```{r}
# Input the metric into the Tuned Wf to find the results

#Collect metrics

fit_tuned %>% tune::collect_metrics()

fit_tuned %>% tune::collect_metrics() %>% 
  ggplot(aes(neighbors,mean)) +
  geom_line(linewidth = 1.5, alpha = 0.6) +
  geom_point(size = 2) +
  facet_wrap(~ .metric, scales = "free", nrow = 2)
```

## Exercise 9

Use `tune::show_best` and `tune::select_best` with argument **"roc_auc"** to find the best **k** for the knn classification model. Then

1.  update the workflow using `tune::finalize_workflow` to set the best k value.
2.  use `tune::last_fit` with the updated workflow from step 1, evaluated on the split data from exercise 2 to finalize the fit.
3.  use `tune::collect_metrics()` to get the metrics for the best fit
4.  use `tune::collect_predictions()` to get the predictions and plot the **roc_auc** as in the prior exercises

## YOUR ANSWER Q9:

```{r}
fit_tuned %>%  tune::show_best(metric = "roc_auc")

best_model_knn <-fit_tuned %>%  tune::select_best(metric = "roc_auc")

final_wf_knn <- workflow74_knn_update %>% 
  tune::finalize_workflow(best_model_knn)

final_fit_knn <- final_wf_knn %>% 
  tune::last_fit(data74_splits)

final_fit_knn %>% tune::collect_metrics()

final_fit_knn %>% tune::collect_predictions() %>% 
  yardstick::roc_curve(.pred_No, truth = churn) %>%
  autoplot()
```

## Exercise 10: clustering

Load the data for this exercise as below and plot it, and then create an analysis dataset with the cluster labels removed

## YOUR ANSWER Q10:

```{r}
# read the data
labelled_points <- readr::read_csv("C:/Users/abedi/Downloads/lab_5_clusters.csv", show_col_types = FALSE)

labelled_points %>%   ggplot(aes(x1, x2, color = cluster)) +
  geom_point(alpha = 0.3) + 
  theme(legend.position="none")

points <- labelled_points %>%  select(-cluster)


# remove cluster labels to make the analysis dataset
points <-
  labelled_points |>
  select(-cluster)

view(labelled_points)
```

You have frequently used `broom::augment` to combine a model with the data set, and `broom::tidy` to summarize model components; `broom::glance` is used to similarly to summarize goodness-of-fit metrics.

Now perform k-means clustering on the points data for different values of k as follows:

```{r}
# make tidy table
kclusters <- tibble(k = 1:9) %>% 
  mutate(kclusters = purrr::map(k, ~stats::kmeans(points, .x)),
         tidied = purrr::map(kclusters, broom::tidy),
         glanced = purrr::map(kclusters, broom::glance),
         augment = purrr::map(kclusters, broom::augment, points)
         )


kclusts <-
  # number of clusters from 1-9
  tibble(k = 1:9) |>
  # mutate to add columns
  mutate(
    # a list-column with the results of the kmeans function (clustering)
    kclust = purrr::map(k, ~stats::kmeans(points, .x)),
    # a list-column with the results broom::tidy applied to the clustering results
    tidied = purrr::map(kclust, broom::tidy),
    # a list-column with the results broom::glance applied to the clustering results
    glanced = purrr::map(kclust, broom::glance),
    # a list-column with the results broom::augment applied to the clustering results
    augmented = purrr::map(kclust, broom::augment, points)
  )

kclusters
kclusts
```

**(i)** Create 3 variables by `tidyr::unnest`ing the appropriate columns of **kclusts**

```{r}
# take kclusts and use tidy::unnest() on the appropriate columns
clusters <- kclusts %>% 
  tidyr::unnest(cols = c(tidied))

clusterings <- kclusts %>% 
  tidyr::unnest(cols = c(glanced))

assignments <- kclusts %>% 
  tidyr::unnest(cols = c(augmented))
```

**(ii)** Use the **assignments** variable to plot the cluster assignments generated by `stats::kmeans`

```{r}
# plot the points assigned to each cluster
plot_1<- assignments |> ggplot(aes(x = x1, y = x2)) +
  geom_point(aes(color = .cluster), alpha = 0.8) +
  facet_wrap(~ k) + theme(legend.position="none")

plot_1
```

**(iii)** Use the **clusters** variable to add the cluster centers to the plot

```{r}
# on the last plot, mark the cluster centres with an X
plot_1 + geom_point(data = clusters, size = 10, shape = "x")
```

**(iv)** Use the **clusterings** variable to plot the total within sum of squares value by number of clusters.

```{r}
# make a separate line-and-point plot with the tot-withinss data by cluster number
clusterings |> ggplot(aes(k, tot.withinss)) +
  geom_line() +
  geom_point()



```

**(v)** Visually and by the “elbow” heursistic, we should use k=3, i.e. k=3 should give good results: good fit with low model complexity.

You're done and ready to submit your work! Save, stage, commit, and push all remaining changes. You can use the commit message "Done with Lab 5!" , and make sure you have committed and pushed all changed files to GitHub (your Git pane in RStudio should be empty) and that **all** documents are updated in your repo on GitHub.

::: callout-important
## Submission

I will pull (copy) everyone's repository submissions at 5:00pm on the Sunday following class, and I will work only with these copies, so anything submitted after 5:00pm will not be graded. (**don't forget to commit and then push your work!**)
:::

## Grading

Total points available: 30 points.

![](images/rubric10.png){fig-align="center" width="600"}
